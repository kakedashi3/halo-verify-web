<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./style.css" />
    <title>HaLo Verify</title>
  </head>
  <body>
    <div class="wrapper">
      <div class="width">
        <div class="box">
          <h1>Halo Detected</h1>

          <h2 id="title1">Primary Public Key Hash</h2>
          <p id="pkey1">Unknown</p>

          <h2 id="title2">Secondary Public Key Hash</h2>
          <p id="pkey2">Unknown</p>

          <a id="scan" class="button" onClick="readKeyU2F();">Scan</a>
        </div>

        <svg
          width="54"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 54 17"
        >
          <a href="https://kong.land">
          <path
            d="M12.338 16.713h-4.9L4.42 9.143l.12 7.57H0V.298h4.54l-.119 7.038L7.1.298h4.791l-3.626 7.92 4.073 8.495Zm13.154-8.155c0 2.502-.585 4.537-1.753 6.103C22.577 16.221 21.064 17 19.198 17c-1.655 0-3.075-.599-4.258-1.797-1.488-1.516-2.232-3.792-2.232-6.825 0-2.906.777-5.128 2.33-6.666C16.192.57 17.561 0 19.143 0c1.939 0 3.481.773 4.628 2.318 1.147 1.545 1.72 3.625 1.72 6.24Zm-4.715.032c0-2.97-.537-4.454-1.612-4.454-.537 0-.965.39-1.285 1.17-.312.722-.468 1.785-.468 3.189 0 1.382.147 2.454.441 3.216.294.762.702 1.143 1.225 1.143.537 0 .951-.376 1.241-1.127.305-.752.458-1.797.458-3.137Zm6.653 8.123V.298h4.334L34.04 6.06l.42 1.17c.155.439.328.946.516 1.52l.469 1.446a121.693 121.693 0 0 1-.382-3.658 30.671 30.671 0 0 1-.13-2.551V.297h4.334v16.416h-4.334l-2.287-6.039a72.53 72.53 0 0 1-.648-1.813c-.192-.563-.361-1.1-.506-1.61a99.78 99.78 0 0 1 .207 3.02c.043.857.065 1.608.065 2.253v4.189H27.43Zm20.232-9.494H54v.68c0 3.161-.483 5.437-1.448 6.826C51.499 16.242 49.942 17 47.88 17c-2.025 0-3.615-.744-4.77-2.233-1.146-1.502-1.72-3.565-1.72-6.187 0-2.658.577-4.753 1.732-6.284C44.276.766 45.855 0 47.858 0c2.657 0 4.585 1.354 5.783 4.061l-4.4 1.574c-.065-.518-.216-.927-.452-1.228-.236-.301-.531-.452-.887-.452-1.249 0-1.873 1.676-1.873 5.029 0 1.424.138 2.46.414 3.104.276.645.715.968 1.317.968.24 0 .458-.057.654-.17a1.47 1.47 0 0 0 .495-.479c.135-.205.24-.455.316-.75.076-.293.114-.621.114-.983h-1.677V7.22Z"
            fill="#040202"
          />
          </a>
        </svg>
      </div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.1.umd.min.js" type="text/javascript">
    </script>
    <script>
      setTimeout(function () {
        document.querySelector("body").classList.add("ready");
      }, 400);

      let currentURL = new URL(window.location.href);

      const fromHexString = hexString =>
          new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));

      function buf2hex(buffer) { // buffer is an ArrayBuffer
        return [...new Uint8Array(buffer)]
          .map(x => x.toString(16).padStart(2, '0'))
          .join('');
      }

      function parseKeys(payload) {
        primaryPublicKeyLength = parseInt('0x' + staticHaloData.slice(0, 2)) * 2;
        primaryPublicKeyRaw = staticHaloData.slice(2, primaryPublicKeyLength + 2);
        primaryPublicKeyHash = ethers.utils.sha256('0x' + primaryPublicKeyRaw.slice(2))

        secondaryPublicKeyLength = parseInt(
          '0x' + staticHaloData.slice(
            primaryPublicKeyLength + 2, 
            primaryPublicKeyLength + 4)) * 2;
        
        secondaryPublicKeyRaw = staticHaloData.slice(
          primaryPublicKeyLength + 4, 
          primaryPublicKeyLength + 
          secondaryPublicKeyLength + 4);

        secondaryPublicKeyHash = ethers.utils.sha256('0x' + secondaryPublicKeyRaw.slice(2))

        tertiaryPublicKeyLength = parseInt(
          '0x' + staticHaloData.slice(
            primaryPublicKeyLength + 
            secondaryPublicKeyLength + 4, 
            primaryPublicKeyLength + 
            secondaryPublicKeyLength + 6)) * 2;
        
        var tertiaryPublicKeyRaw = null;
        var tertiaryPublicKeyHash = null;

        if (tertiaryPublicKeyLength > 0) {
          tertiaryPublicKeyRaw = staticHaloData.slice(
            primaryPublicKeyLength + 
            secondaryPublicKeyLength + 6, 
            primaryPublicKeyLength + 
            secondaryPublicKeyLength + 
            tertiaryPublicKeyLength + 6
          );
          
          tertiaryPublicKeyHash = ethers.utils.sha256('0x' + tertiaryPublicKeyRaw.slice(2))
        }

        const keys = {
          'primaryPublicKeyHash': primaryPublicKeyHash,
          'primaryPublicKeyRaw': primaryPublicKeyRaw,
          'secondaryPublicKeyHash': secondaryPublicKeyHash,
          'secondaryPublicKeyRaw': secondaryPublicKeyRaw,
          'tertiaryPublicKeyHash': tertiaryPublicKeyHash,
          'tertiaryPublicKeyRaw': tertiaryPublicKeyRaw
        }

        return keys
      }

      const staticHaloData = currentURL.searchParams.get("static");

      function prepareVerify(staticHaloData) {
        keys = parseKeys(staticHaloData);

        document.getElementById('scan').innerHTML = "Verify"
        document.getElementById('scan').onclick = function () {
          signU2F();
          return false
        };
        document.getElementById('pkey1').innerHTML = keys["primaryPublicKeyHash"]
        document.getElementById('pkey2').innerHTML = keys["secondaryPublicKeyHash"]
      }

      function genRandomChallenge() {
        let genChallenge = new Uint8Array(2 + 32);
        crypto.getRandomValues(genChallenge);
        genChallenge[0] = 1;
        genChallenge[1] = 1 + (genChallenge[1] % 2); // key number to use (random: 1 or 2)

        genChallenge = buf2hex(genChallenge);

        return genChallenge
      }


      if(staticHaloData) {
        prepareVerify(staticHaloData);
      }

      async function authU2F(reqx) {
        var req = {"publicKey": {
          "allowCredentials": [
            {
              "id": reqx,
              "transports": ['nfc'],
              "type": "public-key"
            }
          ],
          "challenge": new Uint8Array([113, 241, 176, 49, 249, 113, 39, 237, 135, 170, 177, 61, 15, 14, 105, 236, 120, 140, 4, 41, 65, 225, 107, 63, 214, 129, 133, 223, 169, 200, 21, 88]),
          "rpId": "dev.vrfy.ch",
          "timeout": 60000,
          "userVerification": "discouraged"
        }};

        var xdd = await navigator.credentials.get(req);
        return xdd.response.signature;
      }

      // This runs a command to read out the public keys.
      async function readKeyU2F() {
        let res = await authU2F(fromHexString("02"));

        // TODO verify the signature from the result.
        // 4104244D15B9E21146765B855D83242CC57900379DB119AC1CC6ADD4BE5AB36037C007DA1531EC2725EF0565CB688482DE534933C5F53D75914052BB19BC1283B1114104CD0C47F2F215B23A47B91D749573FA1C151C9418E60D3CD62A532EEE5A7C14B9492F44FB4B51364B8590742A1FDCFF653F3FB1D78C299D51AD74232CD4A1400C
        //document.getElementById('message').innerHTML = buf2hex(`response: ${res}`)
        console.log(res)
        prepareVerify(res);
      }

      async function signU2F() {
        console.log('sign u2f called')

        document.getElementById('title1').innerHTML = "Challenge"
        document.getElementById('title2').innerHTML = "Signature"

        var req = fromHexString(genRandomChallenge());
        var res = await authU2F(req);

        let qs = new URLSearchParams(window.location.search);
        let pkey1 = qs.get("pkey1");
        let pkey2 = qs.get("pkey2");

        document.getElementById('pkey1').innerHTML = req
        document.getElementById('pkey2').innerHTML = buf2hex(res)

      }

      // async function authBtnU2F() {
      //   var req = fromHexString("0101abc1898af1b0cf120f5d372d26453c28191d2ba81cbc317c7afa6da516105ccd");
      //   var res = await auth(req);
      // }

      // let genChallenge = new Uint8Array(2 + 32);
      // crypto.getRandomValues(genChallenge);
      // genChallenge[0] = 1;
      // genChallenge[1] = 1 + (genChallenge[1] % 2); // key number to use (random: 1 or 2)

      // genChallenge = buf2hex(genChallenge);

      // let ndef;
      // let ctrl;

      // try {
      //   ndef = new NDEFReader();
      //   ctrl = new AbortController();

      // ndef.addEventListener("readingerror", () => {
      //   document.getElementById('message').innerHTML = 'Read error. Please try again.'
      // });

      // ndef.addEventListener("reading", async ({message, serialNumber}) => {
      //   let pkey1;
      //   let pkey2;
      //   let challenge;
      //   let signature;

      //   try {
      //     let url = new URL(new TextDecoder("utf-8").decode(message.records[0].data));
      //     let myURL = new URL(window.location.href);

      //     pkey1 = myURL.searchParams.get("pkey1");
      //     pkey2 = myURL.searchParams.get("pkey2");

      //     document.getElementById('pkey1').innerHTML = pkey1
      //     document.getElementById('pkey2').innerHTML = pkey2
      //   } catch (e) {
      //     document.getElementById('message').innerHTML = 'Read error. Please try again.'
      //     return;
      //   }

      // });

      // document.getElementById("authButton").addEventListener("click", async () => {
      //   document.getElementById("authButton").disabled = true;
      //   document.getElementById("authButtonU2F").disabled = true;
      //   document.getElementById('message').innerHTML = 'Please tap the card and hold it.'

      //   try {
      //     let challenge = fromHexString(genChallenge);
      //     await ndef.write({records: [{recordType: "unknown", data: challenge}]});

      //     document.getElementById('message').innerHTML = 'Reading data... Please hold the card.'

      //     await ndef.scan({signal: ctrl.signal});
      //   } catch (error) {
      //     document.getElementById('message').innerHTML = 'Read error. Please try again.'
      //   }
      // });
      // } catch (e) {
      //   document.getElementById('message').innerHTML = 'WebNFC not available.';
      // }

    </script>
  </body>
</html>
